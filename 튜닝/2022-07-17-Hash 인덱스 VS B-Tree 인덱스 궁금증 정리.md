Q. 해시 탐색법의 시간 복잡도가 O(1)인 이유?
A. 버킷에서 key로 사용되는 hash는 고유하기 때문에 매핑되는 값을 1:1로 탐색이 가능하며, 때문에 다른 값들과의 동등 비교는 할 필요가 없다. 매핑되는 버킷 레코드에서는 실제 디스크 레코드의 메모리 주소 값도 알 수 있기 때문에 디스크에서도 레코드와 관련된 다른 값도 쉽게 꺼내쓸 수 있다.

Q. key를 hash로 컨버트해서 사용하는 이유?
A. 일반적으로 key의 메모리 길이는 가변적이고, hash의 메모리 길이는 고정적인 특성을 가지고 있다. 이 특성을 메모리 관리 목적으로 잘 활용하면 키 관련 메모리 크기를 고정적으로 할당할 수 있기 때문에 메모리 관리에 효율적이다.

Q. 인덱스로 해시 인덱스 보다 B-Tree 인덱스를 사용하는 이유?
A. 해시 탐색은 단 한개의 값을 탐색할 때의 시간복잡도가 O(1)인 것이지, 범위 단위의 탐색에서는 적합하지 않은 자료 구조 방식이다. 해시 방식은 버킷에 값을 저장할 때 정렬 상태로 저장하지 않기 때문이다.

Q. B-Tree의 시간 복잡도가 O(logN)인 이유?
A. 모든 노드는 키 값의 크기에 따라 정렬되어 있고, 이진 탐색처럼 범위 단위로 데이터를 찾기 때문에 탐색 횟수는 최대 B-Tree 높이 값을 벗어나지 않는다.

Q. 인덱스는 어떤 경우에 사용해야 하는가?
A. 인덱스를 적용할 때는 레코드 탐색 비용 VS 인덱스 메모리 비용 중, 어떤게 더 효율적일지를 잘 따져서 적용해야 한다. 일반적으로 인덱스는 탐색이나 비교시에 자주 사용하는 컬럼에만 적용하는게 효율적이고, 테이블 특성상 UPDATE나 DELETE가 빈번하게 발생한다면 인덱스 사용을 자제하는 편이 좋다. 왜냐하면 인덱스는 특정 레코드가 UPDATE되거나 DELETE 되면 과거의 인덱스 값을 제거하는게 아니고 '사용하지않음' 처리만 해놓기 때문에 인덱스용 메모리 사용량이 비대해질 수 있기 때문이다.